-- ------------------------------
-- Export generated by Surrealist on 2024-07-14T22:47:54.485Z
-- ------------------------------

OPTION IMPORT;

-- ------------------------------
-- FUNCTIONS
-- ------------------------------

DEFINE FUNCTION fn::fetch_and_build($accession_ids: array<string>) {
LET $start = time::now();
LET $entry_count = array::len($accession_ids);
LET $distinct = array::len(array::distinct($accession_ids));
LET $groups = array::clump($accession_ids, 500);
FOR $group IN $groups {
LET $json = fn::get_uniprot_data($group);
fn::process_json($json);
};
LET $stop = time::now();
LET $diff = $stop - $start;
LET $outcome = string::concat('Completed fetch and build for ', type::string($entry_count), ' entries with ', type::string($distinct), ' unique entries in ', type::string($diff));
LET $inactive = (SELECT VALUE uniprot_id FROM protein WHERE status = 'Inactive');
RETURN { inactive: $inactive, outcome: $outcome };
} PERMISSIONS FULL;
DEFINE FUNCTION fn::fix_go_terms($terms: option<array>) { RETURN IF ($terms = NONE OR $terms = []) { RETURN NONE; } ELSE { RETURN function($terms) {
	        const [terms] = arguments;
	    try{
	        return terms.map(x=>{
	            var parts = x.toString().split(':');
	            return 'GO:' + parts[1].padStart(7,'0');
	           
	        });
	    }
	    catch{
	        return ['Error for GO Terms']
	    };
	        
	    }; }; } PERMISSIONS FULL;
DEFINE FUNCTION fn::get_go_terms($entry: object) {
LET $terms = (SELECT primaryAccession AS accession, uniProtKBCrossReferences.id AS data FROM $entry);
LET $goterms = (SELECT accession, data[WHERE string::startsWith(type::string($this), 'GO')] FROM $terms);
RETURN (SELECT VALUE fn::fix_go_terms(data) AS data FROM $goterms)[0];
} PERMISSIONS FULL;
DEFINE FUNCTION fn::get_pdb_text($id: string) {
LET $base = 'https://files.rcsb.org/view/';
LET $ep = string::concat($base, $id, '.pdb');
RETURN http::get($ep);
} PERMISSIONS FULL;
DEFINE FUNCTION fn::get_uniprot_data($accession_ids: array<string>) {
LET $base = 'https://rest.uniprot.org/uniprotkb/search?query=';
LET $parts = function($accession_ids) {
	    const [accession_ids] = arguments;
	    var with_chars = accession_ids.map(x=>{
	        return '%28accession%3A' + x + '%29';
	    });
	    return with_chars;
	};
LET $query = array::join($parts, '+OR+');
LET $ep = string::concat($base, $query, '&format=json&size=500');
RETURN http::get($ep, { "Accept-Encoding": 'gzip, deflate, br, zstd' }).results;
} PERMISSIONS FULL;
DEFINE FUNCTION fn::one_hot($items: array<string>, $categories: array<string>) { RETURN function($items, $categories) {
	    const [items,categories] = arguments;
	    var idxArr = items.map(r=>categories.findIndex(x=> x===r));
	    return idxArr.flatMap(i=>{var enc = new Array(categories.length).fill(0,0,categories.length); enc[i] = 1; return enc}); 
	}; } PERMISSIONS FULL;
DEFINE FUNCTION fn::process_json($entries: array<object>) { FOR $entry IN $entries {
LET $acc = $entry.primaryAccession;
LET $prot = type::thing('protein', $acc);
LET $type = $entry.entryType;
IF ($type) = 'Inactive' { INSERT INTO protein { id: $prot, modified: time::now(), status: $type, uniprot_id: $acc } ON DUPLICATE KEY UPDATE status = $type, modified = time::now(), uniprot_id = $acc; } ELSE {
LET $rec = type::thing('uniprot_meta', $acc);
LET $json_url = string::concat('https://rest.uniprot.org/uniprotkb/', $acc, '.json');
LET $page_url = string::concat('https://uniprot.org/uniprotkb/', $acc, '/entry');
INSERT INTO uniprot_meta (id, json_url, metadata, modified, page_url, protein) VALUES ($rec, $json_url, $entry, time::now(), $page_url, $prot) ON DUPLICATE KEY UPDATE metadata = $input.metadata, modified = $input.modified;
LET $sequence = $entry.sequence.value;
LET $seqArr = array::slice(string::split($sequence, ''), 1, -1);
LET $goterms = fn::get_go_terms($entry);
LET $seqRec = type::thing('sequence', $acc);
INSERT INTO protein (go_terms, id, modified, sequence, status, uniprot_id, uniprot_meta) VALUES ($goterms, $prot, time::now(), $seqRec, $type, $acc, $rec) ON DUPLICATE KEY UPDATE sequence = $input.sequence, status = $input.status, modified = $input.modified, go_terms = $input.go_terms, uniprot_id = $input.uniprot_id, uniprot_meta = $input.uniprot_meta;
INSERT INTO sequence (id, modified, protein, seq_array, sequence) VALUES ($seqRec, time::now(), $prot, $seqArr, $sequence) ON DUPLICATE KEY UPDATE modified = $input.modified, protein = $input.protein, seq_array = $input.seq_array, sequence = $input.sequence;
};
}; } PERMISSIONS FULL;

-- ------------------------------
-- TABLE: datasets
-- ------------------------------

DEFINE TABLE datasets TYPE ANY SCHEMAFULL PERMISSIONS NONE;

DEFINE FIELD description ON datasets TYPE option<string> PERMISSIONS FULL;
DEFINE FIELD metadata ON datasets FLEXIBLE TYPE option<object> PERMISSIONS FULL;
DEFINE FIELD modified ON datasets TYPE datetime VALUE time::now() PERMISSIONS FULL;
DEFINE FIELD name ON datasets TYPE string PERMISSIONS FULL;
DEFINE FIELD precomputed_components ON datasets TYPE option<array<record<precomputed>>> PERMISSIONS FULL;
DEFINE FIELD precomputed_components[*] ON datasets TYPE record<precomputed> PERMISSIONS FULL;

-- ------------------------------
-- TABLE: features
-- ------------------------------

DEFINE TABLE features TYPE ANY SCHEMAFULL PERMISSIONS NONE;

DEFINE FIELD feature_esm_embed ON features TYPE option<array<float>> PERMISSIONS FULL;
DEFINE FIELD feature_esm_embed[*] ON features TYPE float PERMISSIONS FULL;
DEFINE FIELD feature_t5_embed ON features TYPE option<array<float>> PERMISSIONS FULL;
DEFINE FIELD feature_t5_embed[*] ON features TYPE float PERMISSIONS FULL;
DEFINE FIELD protein ON features TYPE record<protein> PERMISSIONS FULL;
DEFINE FIELD uniprot_id ON features TYPE string PERMISSIONS FULL;

-- ------------------------------
-- TABLE: go_term
-- ------------------------------

DEFINE TABLE go_term TYPE ANY SCHEMAFULL PERMISSIONS NONE;

DEFINE FIELD go_term ON go_term TYPE string PERMISSIONS FULL;
DEFINE FIELD namespace ON go_term TYPE string PERMISSIONS FULL;

-- ------------------------------
-- TABLE: pdb
-- ------------------------------

DEFINE TABLE pdb TYPE ANY SCHEMAFULL PERMISSIONS NONE;

DEFINE FIELD metadata ON pdb FLEXIBLE TYPE option<object> PERMISSIONS FULL;
DEFINE FIELD pdb ON pdb TYPE string PERMISSIONS FULL;
DEFINE FIELD pdb_file_text ON pdb TYPE option<string> PERMISSIONS FULL;

-- ------------------------------
-- TABLE: precomputed
-- ------------------------------

DEFINE TABLE precomputed TYPE ANY SCHEMAFULL PERMISSIONS NONE;

DEFINE FIELD component_description ON precomputed TYPE string PERMISSIONS FULL;
DEFINE FIELD component_name ON precomputed TYPE string PERMISSIONS FULL;
DEFINE FIELD metadata ON precomputed TYPE option<object> PERMISSIONS FULL;
DEFINE FIELD modified ON precomputed TYPE datetime VALUE time::now() PERMISSIONS FULL;
DEFINE FIELD uri ON precomputed TYPE string PERMISSIONS FULL;

-- ------------------------------
-- TABLE: protein
-- ------------------------------

DEFINE TABLE protein TYPE ANY SCHEMAFULL PERMISSIONS NONE;

DEFINE FIELD datasets ON protein TYPE option<array<record<datasets>>> PERMISSIONS FULL;
DEFINE FIELD datasets[*] ON protein TYPE record<datasets> PERMISSIONS FULL;
DEFINE FIELD features ON protein TYPE option<record<features>> PERMISSIONS FULL;
DEFINE FIELD go_terms ON protein TYPE option<array> PERMISSIONS FULL;
DEFINE FIELD go_terms[*] ON protein TYPE any PERMISSIONS FULL;
DEFINE FIELD modified ON protein TYPE datetime DEFAULT time::now() VALUE time::now() PERMISSIONS FULL;
DEFINE FIELD pdb ON protein TYPE option<array<record<pdb>>> PERMISSIONS FULL;
DEFINE FIELD pdb[*] ON protein TYPE record<pdb> PERMISSIONS FULL;
DEFINE FIELD sequence ON protein TYPE option<record<sequence>> PERMISSIONS FULL;
DEFINE FIELD status ON protein TYPE string PERMISSIONS FULL;
DEFINE FIELD uniprot_id ON protein TYPE string PERMISSIONS FULL;
DEFINE FIELD uniprot_meta ON protein TYPE option<record<uniprot_meta>> PERMISSIONS FULL;

-- ------------------------------
-- TABLE: results
-- ------------------------------

DEFINE TABLE results TYPE NORMAL SCHEMAFULL PERMISSIONS NONE;

DEFINE FIELD date ON results TYPE datetime PERMISSIONS FULL;
DEFINE FIELD description ON results TYPE string PERMISSIONS FULL;
DEFINE FIELD modified ON results TYPE datetime VALUE time::now() PERMISSIONS FULL;

-- ------------------------------
-- TABLE: sequence
-- ------------------------------

DEFINE TABLE sequence TYPE ANY SCHEMAFULL PERMISSIONS NONE;

DEFINE FIELD one_hot ON sequence TYPE option<array<array<int>>> PERMISSIONS FULL;
DEFINE FIELD one_hot[*] ON sequence TYPE array<float> PERMISSIONS FULL;
DEFINE FIELD one_hot[*][*] ON sequence TYPE float PERMISSIONS FULL;
DEFINE FIELD protein ON sequence TYPE record<protein> PERMISSIONS FULL;
DEFINE FIELD seq_array ON sequence TYPE option<array<string>> PERMISSIONS FULL;
DEFINE FIELD seq_array[*] ON sequence TYPE string PERMISSIONS FULL;
DEFINE FIELD sequence ON sequence TYPE string PERMISSIONS FULL;

-- ------------------------------
-- TABLE: uniprot_meta
-- ------------------------------

DEFINE TABLE uniprot_meta TYPE ANY SCHEMAFULL PERMISSIONS NONE;

DEFINE FIELD json_url ON uniprot_meta TYPE option<string> PERMISSIONS FULL;
DEFINE FIELD metadata ON uniprot_meta FLEXIBLE TYPE option<object> PERMISSIONS FULL;
DEFINE FIELD modified ON uniprot_meta TYPE option<datetime> PERMISSIONS FULL;
DEFINE FIELD page_url ON uniprot_meta TYPE option<string> ASSERT IF $value != NONE THEN string::is::url($value) END PERMISSIONS FULL;
DEFINE FIELD protein ON uniprot_meta TYPE record<protein> PERMISSIONS FULL;